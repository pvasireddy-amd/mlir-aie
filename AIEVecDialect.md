<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'aievec' Dialect

Types and operations for AIE vector dialect
[TOC]

## Operations

### `aievec.add` (::xilinx::aievec::AddOp)

_AIE vector add_

AMD-specific advanced add operation that adds two 1-D vectors 
with lane selection. The vector sizes are at least 256 bits.
`$result = `$lhs + $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.add_elem` (::xilinx::aievec::AddElemOp)

_AIE vector add elem_


Syntax:

```
operation ::= `aievec.add_elem` $lhs `,` $rhs attr-dict `:` type($result)
```

AMD-specific aie-ml intrinsic that allows you to perform addition operation
on all types of vectors.`$result = `$lhs + $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.band` (::xilinx::aievec::BandOp)

_AIE vector bitwise and_


Syntax:

```
operation ::= `aievec.band` $lhs `,` $rhs attr-dict `:` type($lhs) `,` type($rhs)
              `,` type($result)
```

AMD-specific intrinsic that computes bitwise and of two vectors and returns
the result.
`$result = band(`$lhs, $rhs`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type
| `rhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type


### `aievec.bneg` (::xilinx::aievec::BnegOp)

_AIE vector bitwise negation_


Syntax:

```
operation ::= `aievec.bneg` $source attr-dict `:` type($result)
```

AMD-specific intrinsic that computes bitwise negation of a vector and
returns the result.
`$result = bneg(`$source`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type


### `aievec.bor` (::xilinx::aievec::BorOp)

_AIE vector bitwise or_


Syntax:

```
operation ::= `aievec.bor` $lhs `,` $rhs attr-dict `:` type($lhs) `,` type($rhs)
              `,` type($result)
```

AMD-specific intrinsic that computes bitwise or of two vectors and returns
the result.
`$result = bor(`$lhs, $rhs`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type
| `rhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type


### `aievec.broadcast` (::xilinx::aievec::BroadcastOp)

_AIE-ML broadcast_

AMD-specific broadcast intrinsic. Extract element index from vector and broadcasts its
value to all lanes of the vector.
`$result = broadcast($source, $idx)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>idx</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose value is non-negative</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.broadcast_scalar` (::xilinx::aievec::BroadcastScalarOp)

_AIE-ML broadcast scalar_

AMD-specific broadcast scalar intrinsic. Broadcasts input value to all vector lanes.
`$result = broadcast_scalar($source)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | bfloat16 type or 32-bit float or 32-bit signless integer or 16-bit signless integer or 8-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.bxor` (::xilinx::aievec::BxorOp)

_AIE vector bitwise xor_


Syntax:

```
operation ::= `aievec.bxor` $lhs `,` $rhs attr-dict `:` type($lhs) `,` type($rhs)
              `,` type($result)
```

AMD-specific intrinsic that computes bitwise xor of two vectors and returns
the result.
`$result = bxor(`$lhs, $rhs`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type
| `rhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or bfloat16 type


### `aievec.cast` (::xilinx::aievec::CastOp)

_AIE cast_

AIE-ML cast intrinsic. Cast values from source data type to result data types.
`$result = cast($source, isResAcc)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>isResAcc</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.cmp` (::xilinx::aievec::CmpOp)

_AIE vector comparison_


Syntax:

```
operation ::= `aievec.cmp` $lhs `,` $rhs ` ` `{` `pred` `=` $pred attr-dict `}` `:` type($lhs) `,` type($rhs)  `,` type($result)
```

AMD-specific intrinsic that performs element-wise comparisonof two input vectors.
The attribute predicate defines which type of comparison is
performed. The following comparisons are supported:

-   equal (mnemonic: `"eq"`)
-   not equal (mnemonic: `"ne"`)
-   signed less than (mnemonic: `"slt"`)
-   unsigned less than (mnemonic: `"ult"`)
-   signed less than or equal (mnemonic: `"sle"`)
-   unsigned less than or equal (mnemonic: `"ule"`)
-   signed greater than (mnemonic: `"sgt"`)
-   unsigned greater than (mnemonic: `"ugt"`)
-   signed greater than or equal (mnemonic: `"sge"`)
-   unsigned greater than or equal (mnemonic: `"uge"`)

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>pred</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | unsigned integer


### `aievec.concat` (::xilinx::aievec::ConcatOp)

_AIE concat_

AMD-specific concat intrinsic. Concatenates two or more smaller
vectors into a bigger vector. The verifier confirms that all the
input vectors have the same number of lanes.
`$result = concat($sources[0], $sources[1], ...)`

Traits: `AlwaysSpeculatableImplTrait`, `InferTypeOpAdaptor`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sources` | variadic of vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.ext` (::xilinx::aievec::ExtOp)

_AIE ext_

AMD-specific vector extract intrinsic. Selects contiguous lanes from 
the source vector, and transfers the data from those lanes to the 
result. The lane selection is controlled by index. There are two cases:
1. Extracted vector fills half of the original vector lanes (e.g. extract v64int8 from v128int8)
2. Extracted vector fills a fourth of the original vector lanes (e.g. extract v32int8 from v128int8)
In the first case, index can be 0 or 1. Index 0 extracts the lower half, and index 1 extracts the upper half.
In the second case, index can be 0 to 3. Index 0 extracts the lowest quarter, index 1 the next quarter, and so on.
`$result = ext($source, $index)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 8</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.ext_elem` (::xilinx::aievec::ExtElemOp)

_AIE extract element_


Syntax:

```
operation ::= `aievec.ext_elem` $source `,` $index attr-dict `:` type($source) `,` type($index) `,` type($result)
```

AMD - specific extract element
                  intrinsic. Extract element determined by index from vector.
    `$result = ext_elem($source, $index)`.
Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values
| `index` | 32-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | bfloat16 type or 32-bit float or 32-bit signless integer or 16-bit signless integer or 8-bit signless integer


### `aievec.fma_conv` (::xilinx::aievec::FMAConvOp)

_AIE2 multiply accumulate convolution_

AMD-specific multiply accumulate convolution intrinsic. Multiply accumulate convolution
operation of (M x N)matrix with (N x 1)kernel.
`$result = mac_convMxN($lhs, $rhs, $acc)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>M</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>N</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>fmsub</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values
| `acc` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.legacyshuffle` (::xilinx::aievec::LegacyShuffleOp)

_AIE2 shuffle_

AMD-specific vector shuffle intrinsic by a specific shuffle mode.
`$result = shuffle($source, $mode)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mode</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.mac` (::xilinx::aievec::FMAOp)

_AIE vector fused multiply-add_

AMD-specific multiply-add operation. It multiplies two 1-D vectors,
and adds the result to an accumulator. The vector sizes are at least
256 bits, and the left operand vector is at least twice the size of
right operand vector. For integers, the lhs and rhs are 8/16/32 bits;
the result and acc are 48-bit or 80-bit accumulator.
`$result = `$lhs * $rhs + $acc`.
Note: the same operator can be used as fmsub operator by setting the
'fmsub' bool to true.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>fmsub</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values
| `acc` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.mac_elem` (::xilinx::aievec::FMAElemOp)

_AIE-ML element-wise vector fused multiply-add_

AMD-specific multiply-add operation. It multiplies two 1-D vectors in the same channel,
and adds the result to an accumulator.
`$result = `$lhs * $rhs + $acc`.
Note: the same operator can be used as fmsub operator by setting the
'fmsub' bool to true.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fmsub</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values
| `acc` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.matmul` (::xilinx::aievec::MatMulOp)

_AIEML matrix-multiply and accummulate_


Syntax:

```
operation ::= `aievec.matmul` $lhs `,` $rhs `,` $acc attr-dict `:` type($lhs) `,`
              type($rhs) `into` type($acc)
```

AMD AIEv2-specific intrinsic that performs a matrix multiplications
between `lhs` and `rhs`, and accumulates the result in `acc`.

Currently, this intrinsic supports the following type combinations:

     lhs                | rhs                | Accumulator
    :------------------:|:------------------:|:-----------------:
     `vector<4x16xi8>`  | `vector<16x8xi4>`  | `vector<4x8xi32>`
     `vector<4x8xi8>`   | `vector<8x8xi8>`   | `vector<4x8xi32>`
     `vector<4x4xi16>`  | `vector<4x8xi8>`   | `vector<4x8xi32>`
     `vector<4x2xi16>`  | `vector<2x8xi16>`  | `vector<4x8xi32>`
     `vector<2x8xi16>`  | `vector<8x8xi8>`   | `vector<2x8xi64>`
     `vector<4x8xi16>`  | `vector<8x4xi8>`   | `vector<4x4xi64>`
     `vector<2x4xi16>`  | `vector<4x8xi16>`  | `vector<2x8xi64>`
     `vector<4x4xi16>`  | `vector<4x4xi16>`  | `vector<4x4xi64>`
     `vector<4x2xi32>`  | `vector<2x4xi16>`  | `vector<4x4xi64>`
     `vector<4x8xbf16>` | `vector<8x4xbf16>` | `vector<4x4xf32>`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | a vector compatible with a lhs operand of matrix-multiply and accumulate
| `rhs` | a vector compatible with a rhs operand of matrix-multiply and accumulate
| `acc` | a vector compatible with an accumulator of matrix-multiply and accumulate

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | a vector compatible with an accumulator of matrix-multiply and accumulate


### `aievec.max` (::xilinx::aievec::MaxOp)

_AIE vector maximum_


Syntax:

```
operation ::= `aievec.max` $lhs `,` $rhs attr-dict `:` type($result)
```

AMD-specific intrinsic that calculates the maximum between two input vectors.
`$result = max(`$lhs, $rhs`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.min` (::xilinx::aievec::MinOp)

_AIE vector minimum_


Syntax:

```
operation ::= `aievec.min` $lhs `,` $rhs attr-dict `:` type($result)
```

AMD-specific intrinsic that calculates the minimum between two input vectors.
`$result = min(`$lhs, $rhs`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.mul` (::xilinx::aievec::MulOp)

_AIE vector multiply_

AMD-specific multiply operation that multiplies two 1-D vectors.
The vector sizes are at least 256 bits, and the left operand vector 
is at least twice the size of right operand vector. For integers, the
lhs and rhs are 8/16/32 bits, and result is a 48-bit or 80-bit accumulator.
`$result = `$lhs * $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.mul_conv` (::xilinx::aievec::MulConvOp)

_AIE2 multiply convolution_

AMD-specific multiply convolution intrinsic. Multiply convolution operation
of (M x N)matrix with (N x 1)kernel.
`$result = mul_convMxN($lhs, $rhs)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>M</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>N</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.mul_elem` (::xilinx::aievec::MulElemOp)

_AIE-ML vector element-wise multiply_

AMD-specific multiply operation that multiplies two 1-D vectors in the same channel.
The vector sizes are at least 512 bits.
`$result = `$lhs * $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.neg` (::xilinx::aievec::NegOp)

_AIE vector negative_


Syntax:

```
operation ::= `aievec.neg` $source attr-dict `:` type($result)
```

AMD-specific intrinsic that negates the vector and returns the result.
`$result = neg(`$source`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.pack` (::xilinx::aievec::PackOp)

_AIE pack_

AMD-specific pack intrinsic. Pack a vector of 16-bit values into
a vector of 8-bit values.
`$result = pack($source)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.sel` (::xilinx::aievec::SelOp)

_AIE vector lane wise selection_


Syntax:

```
operation ::= `aievec.sel` $lhs `,` $rhs `,` $sel attr-dict `:` type($lhs) `,` type($rhs) `,` type($sel) `,` type($result)
```

AMD-specific intrinsic that performs lane wise selection between two input vectors, if a bit of sel is zero, the lane of vector lhs is selected, else the lane of vector rhs is selected.
`$result = sel(`$lhs, $rhs, $sel`).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values
| `sel` | unsigned integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.select` (::xilinx::aievec::SelectOp)

_AIE vector lane selection_

AMD-specific vector lane selection operation. It selects between the
first set of lanes or the second one according to the value in 'select'. 
If the bit in select is 0(1), it returns the value in the first(second) 
set of lanes.
`$result = `select32($select, $xbuff, $xstart, $xoffsets, $ystart, $yoffsets)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>select</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>ystart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>yoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>yoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>ysquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `xbuff` | vector of any type values
| `ybuff` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.shift` (::xilinx::aievec::ShiftOp)

_AIE2 concat and shift_

AMD-specific shift intrinsic. Concatenates two
vectors into a bigger vector, interprets them as a vector of 128 bytes
and returns v1::v2[shift: shift+64]. `shift` is the number of bytes to 
be shifted. The verifier confirms that all the input and result vectors 
have the same number of lanes and element types.
`$result = shift($lhs, $rhs, $shift)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>isAcc</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values
| `shift` | 32-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.shuffle` (::xilinx::aievec::ShuffleOp)

_AIE2 shuffle_


Syntax:

```
operation ::= `aievec.shuffle` $lhs (`,` $rhs^)? $mode attr-dict `:` type($result)
```

AMD AIEv2-specific vector shuffle. It performs a shuffle of the elements of
1 or 2 input vectors using the specified shuffle mode. The shuffle mode is
specified as:

  `t<width>_<r>x<c>(_(hi|lo))?`

where `<width>` is the bitwidth of the vector element type, `<r>` and `<c>`
are the number of rows and columns that will be transposed to perform the
shuffle, and, for modes that require two 512-bit vectors, `hi` and `lo`
indicate which part of the resulting extended 1024-bit vector will be
assembled and returned.

E.g.: `t32_4x8` would take two 512-bit vectors, `lhs` and `rhs`, with 16
elements of 32 bits each. The resulting vector would contain either the
least (`lo`) or most (`hi`) significant 16 elements of the 32 element vector
that would result from selecting, out of the concatenated vectors `lhs:rhs`,
8 blocks of 4 elements, each block taking one of every 8 elements starting
from the block index.

That is, for two `vector<16xi32>` operands containing:
```
lhs = [0,   1,  2,  3, ..., 15]
rhs = [17, 18, 19, 20, ..., 31]
```

The first 8 blocks would be:
```
b0 = [0,  8, 16, 24]
b1 = [1,  9, 17, 25]
b2 = [2, 10, 18, 26]
b3 = [3, 11, 19, 27]
   ...
b7 = [7, 15, 23, 31]
```

`t32_4x8_lo` would return first four blocks:
```
result = [0, 8, 16, 24, 1, 9, 17, 25, ..., 3, 11, 19, 27]
```

And `t32_4x8_hi` would return the last four blocks:
```
result = [4, 12, 20, 28, 5, 13, 21, 29, ..., 7, 15, 24, 31]
```

It can be seen as flattened 4x8 matrix, split in two 16-element halfs, being
tranposed to a 8x4 arrangement. In the example above:

```
lhs = [ 0,  1,  2,  3,  4,  5,  6,  7]
      [ 8,  9, 10, 11, 12, 13, 14, 15]
rhs = [16, 17, 18, 19, 20, 21, 22, 23]
      [24, 25, 26, 27, 28, 29, 30, 31]
```

Would result in:
```
t32_4x8_lo = [0,  8, 16, 24]
             [1,  9, 17, 25]
             [2, 10, 18, 26]
             [3, 11, 19, 27]
t32_4x8_hi = [4, 12, 20, 28]
             [5, 13, 21, 29]
             [6, 14, 22, 30]
             [7, 15, 23, 31]
```

A special mode, `t16_1x2_flip`, swaps each pair of elements in a vector with
32 16-bit elements. E.g.:
```
lhs = [0, 1, 2, 3, ..., 28, 29, 30, 31]
```
Would result in:
```
t16_1x2_flip = [1, 0, 3, 2, ..., 29, 28, 31, 30]
```

The list of supported shuffle modes, required operands, and associated
vector types are the following:

     Shuffle Mode       | Operands           | Types Supported
    :------------------:|:------------------:|:------------------:
     t8_8x4             | `lhs`              | `vector<64xi8>`
     t8_4x8             | ^                  | ^
     t8_8x8             | ^                  | ^
     t8_16x4            | ^                  | ^
     t8_4x16            | ^                  | ^
     t8_64x2_lo         | `lhs` & `rhs`      | ^
     t8_64x2_hi         | ^                  | ^
     t8_2x64_lo         | ^                  | ^
     t8_2x64_hi         | ^                  | ^
     t16_4x2            | `lhs`              | `vector<32xi16>` or `vector<32xbf16>`
     t16_2x4            | ^                  | ^
     t16_4x4            | ^                  | ^
     t16_8x2            | ^                  | ^
     t16_2x8            | ^                  | ^
     t16_8x4            | ^                  | ^
     t16_4x8            | ^                  | ^
     t16_16x2           | ^                  | ^
     t16_2x16           | ^                  | ^
     t16_1x2_flip       | ^                  | ^
     t16_32x2_lo        | `lhs` & `rhs`      | ^
     t16_32x2_hi        | ^                  | ^
     t16_2x32_lo        | ^                  | ^
     t16_2x32_hi        | ^                  | ^
     t16_16x4_lo        | ^                  | ^
     t16_16x4_hi        | ^                  | ^
     t16_4x16_lo        | ^                  | ^
     t16_4x16_hi        | ^                  | ^
     t32_4x4            | `lhs`              | `vector<16xi32>` or `vector<16xf32>`
     t32_16x2_lo        | `lhs` & `rhs`      | ^
     t32_16x2_hi        | ^                  | ^
     t32_2x16_lo        | ^                  | ^
     t32_2x16_hi        | ^                  | ^
     t32_8x4_lo         | ^                  | ^
     t32_8x4_hi         | ^                  | ^
     t32_4x8_lo         | ^                  | ^
     t32_4x8_hi         | ^                  | ^
     t64_8x2_lo         | ^                  | `vector<8xi64>`
     t64_8x2_hi         | ^                  | ^
     t64_2x8_lo         | ^                  | ^
     t64_2x8_hi         | ^                  | ^
     t128_4x2_lo        | ^                  | `vector<4xi128>`
     t128_4x2_hi        | ^                  | ^
     t128_2x4_lo        | ^                  | ^
     t128_2x4_hi        | ^                  | ^
     t256_2x2_lo        | ^                  | `vector<2xi256>`
     t256_2x2_hi        | ^                  | ^
     t512_1x2_lo        | ^                  | `vector<1xi512>`
     t512_1x2_hi        | ^                  | ^

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mode</code></td><td>::xilinx::aievec::ShuffleModeAttr</td><td><details><summary>Shuffle mode for AIEVec shuffle operations</summary>{{% markdown %}}Enum cases:
* t8_64x2_lo (`T8_64X2_LO`)
* t8_64x2_hi (`T8_64X2_HI`)
* t16_32x2_lo (`T16_32X2_LO`)
* t16_32x2_hi (`T16_32X2_HI`)
* t32_16x2_lo (`T32_16X2_LO`)
* t32_16x2_hi (`T32_16X2_HI`)
* t64_8x2_lo (`T64_8X2_LO`)
* t64_8x2_hi (`T64_8X2_HI`)
* t128_4x2_lo (`T128_4X2_LO`)
* t128_4x2_hi (`T128_4X2_HI`)
* t256_2x2_lo (`T256_2X2_LO`)
* t256_2x2_hi (`T256_2X2_HI`)
* t128_2x4_lo (`T128_2X4_LO`)
* t128_2x4_hi (`T128_2X4_HI`)
* t64_2x8_lo (`T64_2X8_LO`)
* t64_2x8_hi (`T64_2X8_HI`)
* t32_2x16_lo (`T32_2X16_LO`)
* t32_2x16_hi (`T32_2X16_HI`)
* t16_2x32_lo (`T16_2X32_LO`)
* t16_2x32_hi (`T16_2X32_HI`)
* t8_2x64_lo (`T8_2X64_LO`)
* t8_2x64_hi (`T8_2X64_HI`)
* t512_1x2_lo (`T512_1X2_LO`)
* t512_1x2_hi (`T512_1X2_HI`)
* t16_16x4_lo (`T16_16X4_LO`)
* t16_16x4_hi (`T16_16X4_HI`)
* t16_4x16_lo (`T16_4X16_LO`)
* t16_4x16_hi (`T16_4X16_HI`)
* t16_8x4 (`T16_8X4`)
* t16_4x8 (`T16_4X8`)
* t32_8x4_lo (`T32_8X4_LO`)
* t32_8x4_hi (`T32_8X4_HI`)
* t32_4x8_lo (`T32_4X8_LO`)
* t32_4x8_hi (`T32_4X8_HI`)
* t32_4x4 (`T32_4X4`)
* t8_8x8 (`T8_8X8`)
* t8_16x4 (`T8_16X4`)
* t8_4x16 (`T8_4X16`)
* t16_1x2_flip (`T16_1X2_flip`)
* t16_4x4 (`T16_4X4`)
* t16_4x2 (`T16_4X2`)
* t16_2x4 (`T16_2X4`)
* t16_8x2 (`T16_8X2`)
* t16_2x8 (`T16_2X8`)
* t16_16x2 (`T16_16X2`)
* t16_2x16 (`T16_2X16`)
* t8_8x4 (`T8_8X4`)
* t8_4x8 (`T8_4X8`){{% /markdown %}}</details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 128-bit signless integer or 256-bit signless integer or 512-bit signless integer or bfloat16 type or 32-bit float
| `rhs` | 512-bit wide vector, of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 128-bit signless integer or 256-bit signless integer or 512-bit signless integer or bfloat16 type or 32-bit float

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.srs` (::xilinx::aievec::SRSOp)

_AIE srs_

AMD-specific shift-round-saturate intrinsic. Moves values from
accumulator data type to AIE vector data types. The adjustment in
precision is controlled by the shift parameter.
`$result = srs($source, $shift)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values
| `shift` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.sub` (::xilinx::aievec::SubOp)

_AIE vector subtract_

AMD-specific advanced sub operation that subtracts two 1-D vectors
with lane selection. The vector sizes are at least 256 bits.
`$result = `$lhs - $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.sub_elem` (::xilinx::aievec::SubElemOp)

_AIE vector sub elem_


Syntax:

```
operation ::= `aievec.sub_elem` $lhs `,` $rhs attr-dict `:` type($result)
```

AMD-specific aie-ml intrinsic that allows you to perform substraction operation
on all types of vectors.`$result = `$lhs - $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values
| `rhs` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.unpack` (::xilinx::aievec::UnpackOp)

_AIE unpack_

AMD-specific unpack intrinsic. Unpack a vector of 8-bit values into
a vector of 16-bit values.
`$result = unpack($source)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.upd` (::xilinx::aievec::UPDOp)

_AIE upd_

AMD-specific update intrinsic. General upd intrinsic updates contiguous
lanes of the result vector from a smaller source vector. This form of 
upd intrinsic combines the load of data from memory into a vector 
register, and then updating the lanes of the result vector using it. 
`$result = upd($source[$indices], $offset, $index)`

Traits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 1</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | shaped of any type values
| `indices` | variadic of index
| `vector` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


### `aievec.ups` (::xilinx::aievec::UPSOp)

_AIE ups_

AMD-specific upshift intrinsic. Moves data from AIE vector data type
to accumulator data type. The adjustment in precision is controlled by
the shift parameter.
`$result = ups($source, $shift)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>shift</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose value is non-negative</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values


## Attributes

### ShuffleModeAttr

Shuffle mode for AIEVec shuffle operations

Syntax:

```
#aievec.mode<
  ::xilinx::aievec::ShuffleMode   # value
>
```

Enum cases:
* t8_64x2_lo (`T8_64X2_LO`)
* t8_64x2_hi (`T8_64X2_HI`)
* t16_32x2_lo (`T16_32X2_LO`)
* t16_32x2_hi (`T16_32X2_HI`)
* t32_16x2_lo (`T32_16X2_LO`)
* t32_16x2_hi (`T32_16X2_HI`)
* t64_8x2_lo (`T64_8X2_LO`)
* t64_8x2_hi (`T64_8X2_HI`)
* t128_4x2_lo (`T128_4X2_LO`)
* t128_4x2_hi (`T128_4X2_HI`)
* t256_2x2_lo (`T256_2X2_LO`)
* t256_2x2_hi (`T256_2X2_HI`)
* t128_2x4_lo (`T128_2X4_LO`)
* t128_2x4_hi (`T128_2X4_HI`)
* t64_2x8_lo (`T64_2X8_LO`)
* t64_2x8_hi (`T64_2X8_HI`)
* t32_2x16_lo (`T32_2X16_LO`)
* t32_2x16_hi (`T32_2X16_HI`)
* t16_2x32_lo (`T16_2X32_LO`)
* t16_2x32_hi (`T16_2X32_HI`)
* t8_2x64_lo (`T8_2X64_LO`)
* t8_2x64_hi (`T8_2X64_HI`)
* t512_1x2_lo (`T512_1X2_LO`)
* t512_1x2_hi (`T512_1X2_HI`)
* t16_16x4_lo (`T16_16X4_LO`)
* t16_16x4_hi (`T16_16X4_HI`)
* t16_4x16_lo (`T16_4X16_LO`)
* t16_4x16_hi (`T16_4X16_HI`)
* t16_8x4 (`T16_8X4`)
* t16_4x8 (`T16_4X8`)
* t32_8x4_lo (`T32_8X4_LO`)
* t32_8x4_hi (`T32_8X4_HI`)
* t32_4x8_lo (`T32_4X8_LO`)
* t32_4x8_hi (`T32_4X8_HI`)
* t32_4x4 (`T32_4X4`)
* t8_8x8 (`T8_8X8`)
* t8_16x4 (`T8_16X4`)
* t8_4x16 (`T8_4X16`)
* t16_1x2_flip (`T16_1X2_flip`)
* t16_4x4 (`T16_4X4`)
* t16_4x2 (`T16_4X2`)
* t16_2x4 (`T16_2X4`)
* t16_8x2 (`T16_8X2`)
* t16_2x8 (`T16_2X8`)
* t16_16x2 (`T16_16X2`)
* t16_2x16 (`T16_2X16`)
* t8_8x4 (`T8_8X4`)
* t8_4x8 (`T8_4X8`)
#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::xilinx::aievec::ShuffleMode` | an enum of type ShuffleMode |

