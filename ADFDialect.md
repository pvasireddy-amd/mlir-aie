<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'ADF' Dialect

Types and operations for the ADF dialect
This is an MLIR dialect designed to capture the Xilinx Adaptive Data Flow
(ADF) Graph semantics.  This dialect is intended to be converible to/from the
C++ graph syntax, but to represent the graph abstractly, rather than at
the C++ syntactic level.

[TOC]

## Operations

### `ADF.graph` (::xilinx::ADF::GraphOp)

_An ADF graph operation_


Syntax:

```
operation ::= `ADF.graph` `(` $name `)` regions attr-dict
```

An operation that represents an ADF graph.  This operation determines
the name of the graph and contains a single region containing ADF
dialect operations. For example, 

```mlir
ADF.graph("name") {
  your_graph_operations
}
```

Traits: `AlwaysSpeculatableImplTrait`, `NoTerminator`, `SingleBlock`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>


### `ADF.inout_port` (::xilinx::ADF::GraphInOutOp)

_Graph input/output port operation_


Syntax:

```
operation ::= `ADF.inout_port` `(` $name `)` $inp attr-dict `:` `(`type($inp) `)` `->` type(results)
```

An operation representing a dual input/output of an ADF graph.
This is usually used to represent inout parameter val=ues

```mlir
  %2 = ADF.inout_port("name") %3 : (!ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>                                           
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inp` | 

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | 


### `ADF.input_port` (::xilinx::ADF::GraphInputOp)

_Graph input port operation_


Syntax:

```
operation ::= `ADF.input_port` `(` $name `)` $value attr-dict `->` type($output)
```

An operation representing a primary input of an ADF graph. 
It takes an array attribute as the input
argument. The constant values of the array attribute defines the interface
of whole ADF graph. The first index is a bool integer and 1:i1 means the ADF
graph is based on stream data access mechanism; 0:i1 means it's an adf
window data access. If it's the stream mechanism, then the second index
should set to -1, otherwise, the second index should set to the window size.
e.g. 128 byte.  

The input_port will return an output with "interface" type to propagate the
interface values defined by the argument array attributes.

```mlir
  %0 = ADF.input_port("name")  [1:i1, -1:i32] -> !ADF.interface<!ADF.int32>  // for ADF stream access mechanism
```
  or 
```mlir
  %1 = ADF.input_port("name")  [0:i1, 128:i32] -> !ADF.interface<!ADF.int32> // for ADF window access mechanism 
```

Traits: `AlwaysSpeculatableImplTrait`, `ConstantLike`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | 


### `ADF.kernel` (::xilinx::ADF::KernelOp)

_Call and instantiate a kernel node with proper connections_


Syntax:

```
operation ::= `ADF.kernel` $callee `(` $kernel_inputs `)` attr-dict `:` functional-type($kernel_inputs, results)
```

An operation representing a primitive node in the graph.
This operation refers to a function implementing the kernel.  It takes "window"
types for both its variadic inputs and the op_return to propagate the
window size through entire ADF graph. 

```mlir
  %3 = ADF.kernel @kfunc2(%1, %2) :
          (!ADF.interface<!ADF.int32>, !ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `kernel_inputs` | variadic of 

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | 


### `ADF.output_port` (::xilinx::ADF::GraphOutputOp)

_Graph output port operation_


Syntax:

```
operation ::= `ADF.output_port` `(` $name `)` $inp attr-dict `:` `(`type($inp) `)` `->` type(results)
```

An operation representing a primary input of an ADF graph. 
The operation takes an argument with "window" type and also returns an
"window" type output for final type checking. 

```mlir
  %2 = ADF.output_port("name") %3 : (!ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>                                           
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inp` | 

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | 


## Types

### InterfaceType



Syntax:

```
!ADF.interface<
  mlir::Type   # type
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### ParameterType



Syntax:

```
!ADF.parameter<
  mlir::Type   # type
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### StreamType



Syntax:

```
!ADF.stream<
  mlir::Type   # type
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### WindowType



Syntax:

```
!ADF.window<
  mlir::Type,   # type
  int,   # size
  int   # overlap
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |
| size | `int` |  |
| overlap | `int` |  |

### acc48Type



Syntax: `!ADF.acc48`


### acc80Type



Syntax: `!ADF.acc80`


### accfloatType



Syntax: `!ADF.accfloat`


### cacc48Type



Syntax: `!ADF.cacc48`


### cacc80Type



Syntax: `!ADF.cacc80`


### caccfloatType



Syntax: `!ADF.caccfloat`


### cfloatType



Syntax: `!ADF.cfloat`


### cint16Type



Syntax: `!ADF.cint16`


### cint32Type



Syntax: `!ADF.cint32`


### floatType



Syntax: `!ADF.float`


### int8Type



Syntax: `!ADF.int8`


### int16Type



Syntax: `!ADF.int16`


### int32Type



Syntax: `!ADF.int32`


### int64Type



Syntax: `!ADF.int64`


### uint8Type



Syntax: `!ADF.uint8`


### uint16Type



Syntax: `!ADF.uint16`


### uint32Type



Syntax: `!ADF.uint32`


### uint64Type



Syntax: `!ADF.uint64`


